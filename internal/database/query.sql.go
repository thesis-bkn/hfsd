// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEarliestPendingTask = `-- name: GetEarliestPendingTask :one
SELECT id, source_model_id, output_model_id, task_type, created_at, handled_at, finished_at, prompt_embeds, latents, timesteps, next_latents, image_torchs FROM tasks
WHERE handled_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetEarliestPendingTask(ctx context.Context) (Task, error) {
	row := q.db.QueryRow(ctx, getEarliestPendingTask)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.SourceModelID,
		&i.OutputModelID,
		&i.TaskType,
		&i.CreatedAt,
		&i.HandledAt,
		&i.FinishedAt,
		&i.PromptEmbeds,
		&i.Latents,
		&i.Timesteps,
		&i.NextLatents,
		&i.ImageTorchs,
	)
	return i, err
}

const getFirstAssetByModelID = `-- name: GetFirstAssetByModelID :one
SELECT task_id, "order", pref, "group", prompt, image, image_url, mask, mask_url FROM assets
WHERE task_id = $1
AND "order" = 0
LIMIT 1
`

func (q *Queries) GetFirstAssetByModelID(ctx context.Context, taskID int32) (Asset, error) {
	row := q.db.QueryRow(ctx, getFirstAssetByModelID, taskID)
	var i Asset
	err := row.Scan(
		&i.TaskID,
		&i.Order,
		&i.Pref,
		&i.Group,
		&i.Prompt,
		&i.Image,
		&i.ImageUrl,
		&i.Mask,
		&i.MaskUrl,
	)
	return i, err
}

const getModel = `-- name: GetModel :one
SELECT id, domain, name, base, ckpt, parent, status, created_at FROM models
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetModel(ctx context.Context, id string) (Model, error) {
	row := q.db.QueryRow(ctx, getModel, id)
	var i Model
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Name,
		&i.Base,
		&i.Ckpt,
		&i.Parent,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getRandomBaseAssetsByDomain = `-- name: GetRandomBaseAssetsByDomain :many
SELECT id, image, image_url, mask, mask_url, domain FROM base_assets
WHERE domain = $1
ORDER BY random()
LIMIT $2
`

type GetRandomBaseAssetsByDomainParams struct {
	Domain string
	Limit  int32
}

func (q *Queries) GetRandomBaseAssetsByDomain(ctx context.Context, arg GetRandomBaseAssetsByDomainParams) ([]BaseAsset, error) {
	rows, err := q.db.Query(ctx, getRandomBaseAssetsByDomain, arg.Domain, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BaseAsset
	for rows.Next() {
		var i BaseAsset
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.ImageUrl,
			&i.Mask,
			&i.MaskUrl,
			&i.Domain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScorer = `-- name: GetScorer :one
SELECT name, state_dict FROM scorers
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetScorer(ctx context.Context, name string) (Scorer, error) {
	row := q.db.QueryRow(ctx, getScorer, name)
	var i Scorer
	err := row.Scan(&i.Name, &i.StateDict)
	return i, err
}

const getTaskByOutputModel = `-- name: GetTaskByOutputModel :one
SELECT id, source_model_id, output_model_id, task_type, created_at, handled_at, finished_at, prompt_embeds, latents, timesteps, next_latents, image_torchs FROM tasks
WHERE output_model_id = $1
LIMIT 1
`

func (q *Queries) GetTaskByOutputModel(ctx context.Context, outputModelID pgtype.Text) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByOutputModel, outputModelID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.SourceModelID,
		&i.OutputModelID,
		&i.TaskType,
		&i.CreatedAt,
		&i.HandledAt,
		&i.FinishedAt,
		&i.PromptEmbeds,
		&i.Latents,
		&i.Timesteps,
		&i.NextLatents,
		&i.ImageTorchs,
	)
	return i, err
}

const getTaskWithoutWeight = `-- name: GetTaskWithoutWeight :one
SELECT id, source_model_id, output_model_id
FROM tasks
WHERE output_model_id = $1
LIMIT 1
`

type GetTaskWithoutWeightRow struct {
	ID            int32
	SourceModelID string
	OutputModelID pgtype.Text
}

func (q *Queries) GetTaskWithoutWeight(ctx context.Context, outputModelID pgtype.Text) (GetTaskWithoutWeightRow, error) {
	row := q.db.QueryRow(ctx, getTaskWithoutWeight, outputModelID)
	var i GetTaskWithoutWeightRow
	err := row.Scan(&i.ID, &i.SourceModelID, &i.OutputModelID)
	return i, err
}

const insertAsset = `-- name: InsertAsset :exec
INSERT INTO assets (task_id, "order", prompt, image, image_url, mask, mask_url)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertAssetParams struct {
	TaskID   int32
	Order    int16
	Prompt   string
	Image    []byte
	ImageUrl string
	Mask     []byte
	MaskUrl  pgtype.Text
}

func (q *Queries) InsertAsset(ctx context.Context, arg InsertAssetParams) error {
	_, err := q.db.Exec(ctx, insertAsset,
		arg.TaskID,
		arg.Order,
		arg.Prompt,
		arg.Image,
		arg.ImageUrl,
		arg.Mask,
		arg.MaskUrl,
	)
	return err
}

const insertBaseAsset = `-- name: InsertBaseAsset :exec
INSERT INTO base_assets (id, image, image_url, mask, mask_url, domain)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertBaseAssetParams struct {
	ID       string
	Image    []byte
	ImageUrl string
	Mask     []byte
	MaskUrl  string
	Domain   string
}

func (q *Queries) InsertBaseAsset(ctx context.Context, arg InsertBaseAssetParams) error {
	_, err := q.db.Exec(ctx, insertBaseAsset,
		arg.ID,
		arg.Image,
		arg.ImageUrl,
		arg.Mask,
		arg.MaskUrl,
		arg.Domain,
	)
	return err
}

const insertInferenceTask = `-- name: InsertInferenceTask :exec
INSERT INTO tasks (source_model_id, task_type)
VALUES ($1, 'inference')
`

func (q *Queries) InsertInferenceTask(ctx context.Context, sourceModelID string) error {
	_, err := q.db.Exec(ctx, insertInferenceTask, sourceModelID)
	return err
}

const insertModel = `-- name: InsertModel :exec
INSERT INTO models (id, domain, name, base, ckpt)
VALUES ($1, $2, $3, $4, $5)
`

type InsertModelParams struct {
	ID     string
	Domain string
	Name   string
	Base   string
	Ckpt   []byte
}

func (q *Queries) InsertModel(ctx context.Context, arg InsertModelParams) error {
	_, err := q.db.Exec(ctx, insertModel,
		arg.ID,
		arg.Domain,
		arg.Name,
		arg.Base,
		arg.Ckpt,
	)
	return err
}

const insertPendingModel = `-- name: InsertPendingModel :exec
INSERT INTO models (id, domain, name, parent, status)
VALUES ($1, $2, $3, $4, 'sampling')
`

type InsertPendingModelParams struct {
	ID     string
	Domain string
	Name   string
	Parent string
}

func (q *Queries) InsertPendingModel(ctx context.Context, arg InsertPendingModelParams) error {
	_, err := q.db.Exec(ctx, insertPendingModel,
		arg.ID,
		arg.Domain,
		arg.Name,
		arg.Parent,
	)
	return err
}

const insertSampleTask = `-- name: InsertSampleTask :exec
INSERT INTO tasks(source_model_id, output_model_id, task_type)
VALUES ($1, $2, 'sample')
`

type InsertSampleTaskParams struct {
	SourceModelID string
	OutputModelID pgtype.Text
}

func (q *Queries) InsertSampleTask(ctx context.Context, arg InsertSampleTaskParams) error {
	_, err := q.db.Exec(ctx, insertSampleTask, arg.SourceModelID, arg.OutputModelID)
	return err
}

const listAllTaskWithAsset = `-- name: ListAllTaskWithAsset :many
SELECT tasks.id, tasks.source_model_id, tasks.output_model_id, tasks.task_type, tasks.created_at, tasks.handled_at, tasks.finished_at, tasks.prompt_embeds, tasks.latents, tasks.timesteps, tasks.next_latents, tasks.image_torchs, assets.task_id, assets."order", assets.pref, assets."group", assets.prompt, assets.image, assets.image_url, assets.mask, assets.mask_url
FROM tasks
JOIN assets ON assets.task_id = tasks.id
WHERE assets."order" = 0
ORDER BY tasks.created_at DESC
`

type ListAllTaskWithAssetRow struct {
	Task  Task
	Asset Asset
}

func (q *Queries) ListAllTaskWithAsset(ctx context.Context) ([]ListAllTaskWithAssetRow, error) {
	rows, err := q.db.Query(ctx, listAllTaskWithAsset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllTaskWithAssetRow
	for rows.Next() {
		var i ListAllTaskWithAssetRow
		if err := rows.Scan(
			&i.Task.ID,
			&i.Task.SourceModelID,
			&i.Task.OutputModelID,
			&i.Task.TaskType,
			&i.Task.CreatedAt,
			&i.Task.HandledAt,
			&i.Task.FinishedAt,
			&i.Task.PromptEmbeds,
			&i.Task.Latents,
			&i.Task.Timesteps,
			&i.Task.NextLatents,
			&i.Task.ImageTorchs,
			&i.Asset.TaskID,
			&i.Asset.Order,
			&i.Asset.Pref,
			&i.Asset.Group,
			&i.Asset.Prompt,
			&i.Asset.Image,
			&i.Asset.ImageUrl,
			&i.Asset.Mask,
			&i.Asset.MaskUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssetByTask = `-- name: ListAssetByTask :many
SELECT task_id, "order", pref, "group", prompt, image, image_url, mask, mask_url FROM assets
WHERE task_id = $1
ORDER BY "group", "order"
`

func (q *Queries) ListAssetByTask(ctx context.Context, taskID int32) ([]Asset, error) {
	rows, err := q.db.Query(ctx, listAssetByTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.TaskID,
			&i.Order,
			&i.Pref,
			&i.Group,
			&i.Prompt,
			&i.Image,
			&i.ImageUrl,
			&i.Mask,
			&i.MaskUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeedbackAssetByModelID = `-- name: ListFeedbackAssetByModelID :many
SELECT assets.task_id, assets."order", assets.pref, assets."group", assets.prompt, assets.image, assets.image_url, assets.mask, assets.mask_url FROM tasks
JOIN assets ON tasks.id = assets.task_id
WHERE output_model_id = $1
ORDER BY "group", "order"
`

func (q *Queries) ListFeedbackAssetByModelID(ctx context.Context, outputModelID pgtype.Text) ([]Asset, error) {
	rows, err := q.db.Query(ctx, listFeedbackAssetByModelID, outputModelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.TaskID,
			&i.Order,
			&i.Pref,
			&i.Group,
			&i.Prompt,
			&i.Image,
			&i.ImageUrl,
			&i.Mask,
			&i.MaskUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInferences = `-- name: ListInferences :many
SELECT id, prompt, image, image_url, mask, mask_url, output, output_url, from_model FROM inferences
LIMIT $1
OFFSET $2
`

type ListInferencesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListInferences(ctx context.Context, arg ListInferencesParams) ([]Inference, error) {
	rows, err := q.db.Query(ctx, listInferences, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inference
	for rows.Next() {
		var i Inference
		if err := rows.Scan(
			&i.ID,
			&i.Prompt,
			&i.Image,
			&i.ImageUrl,
			&i.Mask,
			&i.MaskUrl,
			&i.Output,
			&i.OutputUrl,
			&i.FromModel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModelsByDomain = `-- name: ListModelsByDomain :many
SELECT id, domain, name, base, ckpt, parent, status, created_at FROM models
WHERE domain = $1
`

func (q *Queries) ListModelsByDomain(ctx context.Context, domain string) ([]Model, error) {
	rows, err := q.db.Query(ctx, listModelsByDomain, domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Name,
			&i.Base,
			&i.Ckpt,
			&i.Parent,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveHumanPref = `-- name: SaveHumanPref :exec
UPDATE assets
SET pref = $3
WHERE task_id = $1 AND "order" = $2
`

type SaveHumanPrefParams struct {
	TaskID int32
	Order  int16
	Pref   pgtype.Int4
}

func (q *Queries) SaveHumanPref(ctx context.Context, arg SaveHumanPrefParams) error {
	_, err := q.db.Exec(ctx, saveHumanPref, arg.TaskID, arg.Order, arg.Pref)
	return err
}

const saveInference = `-- name: SaveInference :exec
INSERT INTO inferences (id, prompt, image, image_url, mask, mask_url, output, output_url, from_model)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type SaveInferenceParams struct {
	ID        string
	Prompt    pgtype.Text
	Image     []byte
	ImageUrl  string
	Mask      []byte
	MaskUrl   string
	Output    []byte
	OutputUrl string
	FromModel string
}

func (q *Queries) SaveInference(ctx context.Context, arg SaveInferenceParams) error {
	_, err := q.db.Exec(ctx, saveInference,
		arg.ID,
		arg.Prompt,
		arg.Image,
		arg.ImageUrl,
		arg.Mask,
		arg.MaskUrl,
		arg.Output,
		arg.OutputUrl,
		arg.FromModel,
	)
	return err
}

const saveSampleAsset = `-- name: SaveSampleAsset :exec
INSERT INTO assets(
    task_id, "order", "group",
    image, image_url, prompt)
VALUES ($1, $2, $3, $4, $5, $6)
`

type SaveSampleAssetParams struct {
	TaskID   int32
	Order    int16
	Group    pgtype.Int4
	Image    []byte
	ImageUrl string
	Prompt   string
}

func (q *Queries) SaveSampleAsset(ctx context.Context, arg SaveSampleAssetParams) error {
	_, err := q.db.Exec(ctx, saveSampleAsset,
		arg.TaskID,
		arg.Order,
		arg.Group,
		arg.Image,
		arg.ImageUrl,
		arg.Prompt,
	)
	return err
}

const updateModelStatus = `-- name: UpdateModelStatus :exec
UPDATE models
SET status = $2
WHERE id = $1
`

type UpdateModelStatusParams struct {
	ID     string
	Status ModelStatus
}

func (q *Queries) UpdateModelStatus(ctx context.Context, arg UpdateModelStatusParams) error {
	_, err := q.db.Exec(ctx, updateModelStatus, arg.ID, arg.Status)
	return err
}

const updateSampleTasks = `-- name: UpdateSampleTasks :exec
UPDATE tasks
SET latents = $2,
    timesteps = $3,
    next_latents = $4,
    image_torchs = $5,
    prompt_embeds = $6
WHERE id = $1
`

type UpdateSampleTasksParams struct {
	ID           int32
	Latents      []byte
	Timesteps    []byte
	NextLatents  []byte
	ImageTorchs  []byte
	PromptEmbeds []byte
}

func (q *Queries) UpdateSampleTasks(ctx context.Context, arg UpdateSampleTasksParams) error {
	_, err := q.db.Exec(ctx, updateSampleTasks,
		arg.ID,
		arg.Latents,
		arg.Timesteps,
		arg.NextLatents,
		arg.ImageTorchs,
		arg.PromptEmbeds,
	)
	return err
}

const updateSampleToFineTuneTask = `-- name: UpdateSampleToFineTuneTask :exec
UPDATE tasks
SET task_type = 'finetune',
    handled_at = NULL,
    finished_at = NULL
WHERE id = $1
`

func (q *Queries) UpdateSampleToFineTuneTask(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateSampleToFineTuneTask, id)
	return err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
INSERT INTO tasks (id, task_type, source_model_id, handled_at, finished_at)
VALUES ($1, 'sample', '', $2, $3)
ON CONFLICT (id)
DO UPDATE SET
    handled_at = COALESCE(tasks.handled_at, EXCLUDED.handled_at),
    finished_at = COALESCE(tasks.finished_at, EXCLUDED.finished_at)
`

type UpdateTaskStatusParams struct {
	ID         int32
	HandledAt  pgtype.Timestamp
	FinishedAt pgtype.Timestamp
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskStatus, arg.ID, arg.HandledAt, arg.FinishedAt)
	return err
}
