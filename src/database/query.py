# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.26.0
# source: query.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.database import models


GET_EARLIEST_PENDING_TASK = """-- name: get_earliest_pending_task \\:one
SELECT id, source_model_id, output_model_id, task_type, created_at, handled_at, finished_at, prompt_embeds, latents, timesteps, next_latents, image_torchs FROM tasks
WHERE handled_at IS NULL
ORDER BY created_at DESC
LIMIT 1
"""


GET_FIRST_ASSET_BY_MODEL_ID = """-- name: get_first_asset_by_model_id \\:one
SELECT task_id, "order", pref, "group", prompt, image, image_url, mask, mask_url FROM assets
WHERE task_id = :p1
AND "order" = 0
LIMIT 1
"""


GET_MODEL = """-- name: get_model \\:one
SELECT id, domain, name, base, ckpt, parent, status, created_at FROM models
WHERE id = :p1 LIMIT 1
"""


GET_RANDOM_BASE_ASSETS_BY_DOMAIN = """-- name: get_random_base_assets_by_domain \\:many
SELECT id, image, image_url, mask, mask_url, domain FROM base_assets
WHERE domain = :p1
ORDER BY random()
LIMIT :p2
"""


GET_SCORER = """-- name: get_scorer \\:one
SELECT name, state_dict FROM scorers
WHERE name = :p1
LIMIT 1
"""


GET_TASK_BY_OUTPUT_MODEL = """-- name: get_task_by_output_model \\:one
SELECT id, source_model_id, output_model_id, task_type, created_at, handled_at, finished_at, prompt_embeds, latents, timesteps, next_latents, image_torchs FROM tasks
WHERE output_model_id = :p1
LIMIT 1
"""


GET_TASK_WITHOUT_WEIGHT = """-- name: get_task_without_weight \\:one
SELECT id, source_model_id, output_model_id
FROM tasks
WHERE output_model_id = :p1
LIMIT 1
"""


@dataclasses.dataclass()
class GetTaskWithoutWeightRow:
    id: int
    source_model_id: str
    output_model_id: Optional[str]


INSERT_ASSET = """-- name: insert_asset \\:exec
INSERT INTO assets (task_id, "order", prompt, image, image_url, mask, mask_url)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7)
"""


@dataclasses.dataclass()
class InsertAssetParams:
    task_id: int
    order: int
    prompt: str
    image: memoryview
    image_url: str
    mask: Optional[memoryview]
    mask_url: Optional[str]


INSERT_BASE_ASSET = """-- name: insert_base_asset \\:exec
INSERT INTO base_assets (id, image, image_url, mask, mask_url, domain)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6)
"""


@dataclasses.dataclass()
class InsertBaseAssetParams:
    id: str
    image: memoryview
    image_url: str
    mask: memoryview
    mask_url: str
    domain: str


INSERT_INFERENCE_TASK = """-- name: insert_inference_task \\:exec
INSERT INTO tasks (source_model_id, task_type)
VALUES (:p1, 'inference')
"""


INSERT_MODEL = """-- name: insert_model \\:exec
INSERT INTO models (id, domain, name, base, ckpt)
VALUES (:p1, :p2, :p3, :p4, :p5)
"""


@dataclasses.dataclass()
class InsertModelParams:
    id: str
    domain: str
    name: str
    base: str
    ckpt: Optional[memoryview]


INSERT_PENDING_MODEL = """-- name: insert_pending_model \\:exec
INSERT INTO models (id, domain, name, parent, status)
VALUES (:p1, :p2, :p3, :p4, 'sampling')
"""


INSERT_SAMPLE_TASK = """-- name: insert_sample_task \\:exec
INSERT INTO tasks(source_model_id, output_model_id, task_type)
VALUES (:p1, :p2, 'sample')
"""


LIST_ALL_TASK_WITH_ASSET = """-- name: list_all_task_with_asset \\:many
SELECT tasks.id, tasks.source_model_id, tasks.output_model_id, tasks.task_type, tasks.created_at, tasks.handled_at, tasks.finished_at, tasks.prompt_embeds, tasks.latents, tasks.timesteps, tasks.next_latents, tasks.image_torchs, assets.task_id, assets."order", assets.pref, assets."group", assets.prompt, assets.image, assets.image_url, assets.mask, assets.mask_url
FROM tasks
JOIN assets ON assets.task_id = tasks.id
WHERE assets."order" = 0
ORDER BY tasks.created_at DESC
"""


@dataclasses.dataclass()
class ListAllTaskWithAssetRow:
    tasks: Optional[Any]
    assets: Optional[Any]


LIST_ASSET_BY_TASK = """-- name: list_asset_by_task \\:many
SELECT task_id, "order", pref, "group", prompt, image, image_url, mask, mask_url FROM assets
WHERE task_id = :p1
ORDER BY "group", "order"
"""


LIST_FEEDBACK_ASSET_BY_MODEL_ID = """-- name: list_feedback_asset_by_model_id \\:many
SELECT assets.task_id, assets."order", assets.pref, assets."group", assets.prompt, assets.image, assets.image_url, assets.mask, assets.mask_url FROM tasks
JOIN assets ON tasks.id = assets.task_id
WHERE output_model_id = :p1
ORDER BY "group", "order"
"""


LIST_INFERENCES = """-- name: list_inferences \\:many
SELECT id, prompt, image, image_url, mask, mask_url, output, output_url, from_model FROM inferences
LIMIT :p1
OFFSET :p2
"""


LIST_MODELS_BY_DOMAIN = """-- name: list_models_by_domain \\:many
SELECT id, domain, name, base, ckpt, parent, status, created_at FROM models
WHERE domain = :p1
"""


SAVE_HUMAN_PREF = """-- name: save_human_pref \\:exec
UPDATE assets
SET pref = :p3
WHERE task_id = :p1 AND "order" = :p2
"""


SAVE_INFERENCE = """-- name: save_inference \\:exec
INSERT INTO inferences (id, prompt, image, image_url, mask, mask_url, output, output_url, from_model)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9)
"""


@dataclasses.dataclass()
class SaveInferenceParams:
    id: str
    prompt: Optional[str]
    image: memoryview
    image_url: str
    mask: memoryview
    mask_url: str
    output: memoryview
    output_url: str
    from_model: str


SAVE_SAMPLE_ASSET = """-- name: save_sample_asset \\:exec
INSERT INTO assets(
    task_id, "order", "group",
    image, image_url, prompt)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6)
"""


@dataclasses.dataclass()
class SaveSampleAssetParams:
    task_id: int
    order: int
    group: Optional[int]
    image: memoryview
    image_url: str
    prompt: str


UPDATE_MODEL_STATUS = """-- name: update_model_status \\:exec
UPDATE models
SET status = :p2
WHERE id = :p1
"""


UPDATE_SAMPLE_TASKS = """-- name: update_sample_tasks \\:exec
UPDATE tasks
SET latents = :p2,
    timesteps = :p3,
    next_latents = :p4,
    image_torchs = :p5,
    prompt_embeds = :p6
WHERE id = :p1
"""


@dataclasses.dataclass()
class UpdateSampleTasksParams:
    id: int
    latents: Optional[memoryview]
    timesteps: Optional[memoryview]
    next_latents: Optional[memoryview]
    image_torchs: Optional[memoryview]
    prompt_embeds: Optional[memoryview]


UPDATE_SAMPLE_TO_FINE_TUNE_TASK = """-- name: update_sample_to_fine_tune_task \\:exec
UPDATE tasks
SET task_type = 'finetune',
    handled_at = NULL,
    finished_at = NULL
WHERE id = :p1
"""


UPDATE_TASK_STATUS = """-- name: update_task_status \\:exec
INSERT INTO tasks (id, task_type, source_model_id, handled_at, finished_at)
VALUES (:p1, 'sample', '', :p2, :p3)
ON CONFLICT (id)
DO UPDATE SET
    handled_at = COALESCE(tasks.handled_at, EXCLUDED.handled_at),
    finished_at = COALESCE(tasks.finished_at, EXCLUDED.finished_at)
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_earliest_pending_task(self) -> Optional[models.Task]:
        row = self._conn.execute(sqlalchemy.text(GET_EARLIEST_PENDING_TASK)).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            prompt_embeds=row[7],
            latents=row[8],
            timesteps=row[9],
            next_latents=row[10],
            image_torchs=row[11],
        )

    def get_first_asset_by_model_id(self, *, task_id: int) -> Optional[models.Asset]:
        row = self._conn.execute(sqlalchemy.text(GET_FIRST_ASSET_BY_MODEL_ID), {"p1": task_id}).first()
        if row is None:
            return None
        return models.Asset(
            task_id=row[0],
            order=row[1],
            pref=row[2],
            group=row[3],
            prompt=row[4],
            image=row[5],
            image_url=row[6],
            mask=row[7],
            mask_url=row[8],
        )

    def get_model(self, *, id: str) -> Optional[models.Model]:
        row = self._conn.execute(sqlalchemy.text(GET_MODEL), {"p1": id}).first()
        if row is None:
            return None
        return models.Model(
            id=row[0],
            domain=row[1],
            name=row[2],
            base=row[3],
            ckpt=row[4],
            parent=row[5],
            status=row[6],
            created_at=row[7],
        )

    def get_random_base_assets_by_domain(self, *, domain: str, limit: int) -> Iterator[models.BaseAsset]:
        result = self._conn.execute(sqlalchemy.text(GET_RANDOM_BASE_ASSETS_BY_DOMAIN), {"p1": domain, "p2": limit})
        for row in result:
            yield models.BaseAsset(
                id=row[0],
                image=row[1],
                image_url=row[2],
                mask=row[3],
                mask_url=row[4],
                domain=row[5],
            )

    def get_scorer(self, *, name: str) -> Optional[models.Scorer]:
        row = self._conn.execute(sqlalchemy.text(GET_SCORER), {"p1": name}).first()
        if row is None:
            return None
        return models.Scorer(
            name=row[0],
            state_dict=row[1],
        )

    def get_task_by_output_model(self, *, output_model_id: Optional[str]) -> Optional[models.Task]:
        row = self._conn.execute(sqlalchemy.text(GET_TASK_BY_OUTPUT_MODEL), {"p1": output_model_id}).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            prompt_embeds=row[7],
            latents=row[8],
            timesteps=row[9],
            next_latents=row[10],
            image_torchs=row[11],
        )

    def get_task_without_weight(self, *, output_model_id: Optional[str]) -> Optional[GetTaskWithoutWeightRow]:
        row = self._conn.execute(sqlalchemy.text(GET_TASK_WITHOUT_WEIGHT), {"p1": output_model_id}).first()
        if row is None:
            return None
        return GetTaskWithoutWeightRow(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
        )

    def insert_asset(self, arg: InsertAssetParams) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_ASSET), {
            "p1": arg.task_id,
            "p2": arg.order,
            "p3": arg.prompt,
            "p4": arg.image,
            "p5": arg.image_url,
            "p6": arg.mask,
            "p7": arg.mask_url,
        })

    def insert_base_asset(self, arg: InsertBaseAssetParams) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_BASE_ASSET), {
            "p1": arg.id,
            "p2": arg.image,
            "p3": arg.image_url,
            "p4": arg.mask,
            "p5": arg.mask_url,
            "p6": arg.domain,
        })

    def insert_inference_task(self, *, source_model_id: str) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_INFERENCE_TASK), {"p1": source_model_id})

    def insert_model(self, arg: InsertModelParams) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_MODEL), {
            "p1": arg.id,
            "p2": arg.domain,
            "p3": arg.name,
            "p4": arg.base,
            "p5": arg.ckpt,
        })

    def insert_pending_model(self, *, id: str, domain: str, name: str, parent: str) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_PENDING_MODEL), {
            "p1": id,
            "p2": domain,
            "p3": name,
            "p4": parent,
        })

    def insert_sample_task(self, *, source_model_id: str, output_model_id: Optional[str]) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_SAMPLE_TASK), {"p1": source_model_id, "p2": output_model_id})

    def list_all_task_with_asset(self) -> Iterator[ListAllTaskWithAssetRow]:
        result = self._conn.execute(sqlalchemy.text(LIST_ALL_TASK_WITH_ASSET))
        for row in result:
            yield ListAllTaskWithAssetRow(
                tasks=row[0],
                assets=row[1],
            )

    def list_asset_by_task(self, *, task_id: int) -> Iterator[models.Asset]:
        result = self._conn.execute(sqlalchemy.text(LIST_ASSET_BY_TASK), {"p1": task_id})
        for row in result:
            yield models.Asset(
                task_id=row[0],
                order=row[1],
                pref=row[2],
                group=row[3],
                prompt=row[4],
                image=row[5],
                image_url=row[6],
                mask=row[7],
                mask_url=row[8],
            )

    def list_feedback_asset_by_model_id(self, *, output_model_id: Optional[str]) -> Iterator[models.Asset]:
        result = self._conn.execute(sqlalchemy.text(LIST_FEEDBACK_ASSET_BY_MODEL_ID), {"p1": output_model_id})
        for row in result:
            yield models.Asset(
                task_id=row[0],
                order=row[1],
                pref=row[2],
                group=row[3],
                prompt=row[4],
                image=row[5],
                image_url=row[6],
                mask=row[7],
                mask_url=row[8],
            )

    def list_inferences(self, *, limit: int, offset: int) -> Iterator[models.Inference]:
        result = self._conn.execute(sqlalchemy.text(LIST_INFERENCES), {"p1": limit, "p2": offset})
        for row in result:
            yield models.Inference(
                id=row[0],
                prompt=row[1],
                image=row[2],
                image_url=row[3],
                mask=row[4],
                mask_url=row[5],
                output=row[6],
                output_url=row[7],
                from_model=row[8],
            )

    def list_models_by_domain(self, *, domain: str) -> Iterator[models.Model]:
        result = self._conn.execute(sqlalchemy.text(LIST_MODELS_BY_DOMAIN), {"p1": domain})
        for row in result:
            yield models.Model(
                id=row[0],
                domain=row[1],
                name=row[2],
                base=row[3],
                ckpt=row[4],
                parent=row[5],
                status=row[6],
                created_at=row[7],
            )

    def save_human_pref(self, *, task_id: int, order: int, pref: Optional[int]) -> None:
        self._conn.execute(sqlalchemy.text(SAVE_HUMAN_PREF), {"p1": task_id, "p2": order, "p3": pref})

    def save_inference(self, arg: SaveInferenceParams) -> None:
        self._conn.execute(sqlalchemy.text(SAVE_INFERENCE), {
            "p1": arg.id,
            "p2": arg.prompt,
            "p3": arg.image,
            "p4": arg.image_url,
            "p5": arg.mask,
            "p6": arg.mask_url,
            "p7": arg.output,
            "p8": arg.output_url,
            "p9": arg.from_model,
        })

    def save_sample_asset(self, arg: SaveSampleAssetParams) -> None:
        self._conn.execute(sqlalchemy.text(SAVE_SAMPLE_ASSET), {
            "p1": arg.task_id,
            "p2": arg.order,
            "p3": arg.group,
            "p4": arg.image,
            "p5": arg.image_url,
            "p6": arg.prompt,
        })

    def update_model_status(self, *, id: str, status: models.ModelStatus) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_MODEL_STATUS), {"p1": id, "p2": status})

    def update_sample_tasks(self, arg: UpdateSampleTasksParams) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_SAMPLE_TASKS), {
            "p1": arg.id,
            "p2": arg.latents,
            "p3": arg.timesteps,
            "p4": arg.next_latents,
            "p5": arg.image_torchs,
            "p6": arg.prompt_embeds,
        })

    def update_sample_to_fine_tune_task(self, *, id: int) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_SAMPLE_TO_FINE_TUNE_TASK), {"p1": id})

    def update_task_status(self, *, id: int, handled_at: Optional[datetime.datetime], finished_at: Optional[datetime.datetime]) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_TASK_STATUS), {"p1": id, "p2": handled_at, "p3": finished_at})


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_earliest_pending_task(self) -> Optional[models.Task]:
        row = (await self._conn.execute(sqlalchemy.text(GET_EARLIEST_PENDING_TASK))).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            prompt_embeds=row[7],
            latents=row[8],
            timesteps=row[9],
            next_latents=row[10],
            image_torchs=row[11],
        )

    async def get_first_asset_by_model_id(self, *, task_id: int) -> Optional[models.Asset]:
        row = (await self._conn.execute(sqlalchemy.text(GET_FIRST_ASSET_BY_MODEL_ID), {"p1": task_id})).first()
        if row is None:
            return None
        return models.Asset(
            task_id=row[0],
            order=row[1],
            pref=row[2],
            group=row[3],
            prompt=row[4],
            image=row[5],
            image_url=row[6],
            mask=row[7],
            mask_url=row[8],
        )

    async def get_model(self, *, id: str) -> Optional[models.Model]:
        row = (await self._conn.execute(sqlalchemy.text(GET_MODEL), {"p1": id})).first()
        if row is None:
            return None
        return models.Model(
            id=row[0],
            domain=row[1],
            name=row[2],
            base=row[3],
            ckpt=row[4],
            parent=row[5],
            status=row[6],
            created_at=row[7],
        )

    async def get_random_base_assets_by_domain(self, *, domain: str, limit: int) -> AsyncIterator[models.BaseAsset]:
        result = await self._conn.stream(sqlalchemy.text(GET_RANDOM_BASE_ASSETS_BY_DOMAIN), {"p1": domain, "p2": limit})
        async for row in result:
            yield models.BaseAsset(
                id=row[0],
                image=row[1],
                image_url=row[2],
                mask=row[3],
                mask_url=row[4],
                domain=row[5],
            )

    async def get_scorer(self, *, name: str) -> Optional[models.Scorer]:
        row = (await self._conn.execute(sqlalchemy.text(GET_SCORER), {"p1": name})).first()
        if row is None:
            return None
        return models.Scorer(
            name=row[0],
            state_dict=row[1],
        )

    async def get_task_by_output_model(self, *, output_model_id: Optional[str]) -> Optional[models.Task]:
        row = (await self._conn.execute(sqlalchemy.text(GET_TASK_BY_OUTPUT_MODEL), {"p1": output_model_id})).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            prompt_embeds=row[7],
            latents=row[8],
            timesteps=row[9],
            next_latents=row[10],
            image_torchs=row[11],
        )

    async def get_task_without_weight(self, *, output_model_id: Optional[str]) -> Optional[GetTaskWithoutWeightRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_TASK_WITHOUT_WEIGHT), {"p1": output_model_id})).first()
        if row is None:
            return None
        return GetTaskWithoutWeightRow(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
        )

    async def insert_asset(self, arg: InsertAssetParams) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_ASSET), {
            "p1": arg.task_id,
            "p2": arg.order,
            "p3": arg.prompt,
            "p4": arg.image,
            "p5": arg.image_url,
            "p6": arg.mask,
            "p7": arg.mask_url,
        })

    async def insert_base_asset(self, arg: InsertBaseAssetParams) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_BASE_ASSET), {
            "p1": arg.id,
            "p2": arg.image,
            "p3": arg.image_url,
            "p4": arg.mask,
            "p5": arg.mask_url,
            "p6": arg.domain,
        })

    async def insert_inference_task(self, *, source_model_id: str) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_INFERENCE_TASK), {"p1": source_model_id})

    async def insert_model(self, arg: InsertModelParams) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_MODEL), {
            "p1": arg.id,
            "p2": arg.domain,
            "p3": arg.name,
            "p4": arg.base,
            "p5": arg.ckpt,
        })

    async def insert_pending_model(self, *, id: str, domain: str, name: str, parent: str) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_PENDING_MODEL), {
            "p1": id,
            "p2": domain,
            "p3": name,
            "p4": parent,
        })

    async def insert_sample_task(self, *, source_model_id: str, output_model_id: Optional[str]) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_SAMPLE_TASK), {"p1": source_model_id, "p2": output_model_id})

    async def list_all_task_with_asset(self) -> AsyncIterator[ListAllTaskWithAssetRow]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ALL_TASK_WITH_ASSET))
        async for row in result:
            yield ListAllTaskWithAssetRow(
                tasks=row[0],
                assets=row[1],
            )

    async def list_asset_by_task(self, *, task_id: int) -> AsyncIterator[models.Asset]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ASSET_BY_TASK), {"p1": task_id})
        async for row in result:
            yield models.Asset(
                task_id=row[0],
                order=row[1],
                pref=row[2],
                group=row[3],
                prompt=row[4],
                image=row[5],
                image_url=row[6],
                mask=row[7],
                mask_url=row[8],
            )

    async def list_feedback_asset_by_model_id(self, *, output_model_id: Optional[str]) -> AsyncIterator[models.Asset]:
        result = await self._conn.stream(sqlalchemy.text(LIST_FEEDBACK_ASSET_BY_MODEL_ID), {"p1": output_model_id})
        async for row in result:
            yield models.Asset(
                task_id=row[0],
                order=row[1],
                pref=row[2],
                group=row[3],
                prompt=row[4],
                image=row[5],
                image_url=row[6],
                mask=row[7],
                mask_url=row[8],
            )

    async def list_inferences(self, *, limit: int, offset: int) -> AsyncIterator[models.Inference]:
        result = await self._conn.stream(sqlalchemy.text(LIST_INFERENCES), {"p1": limit, "p2": offset})
        async for row in result:
            yield models.Inference(
                id=row[0],
                prompt=row[1],
                image=row[2],
                image_url=row[3],
                mask=row[4],
                mask_url=row[5],
                output=row[6],
                output_url=row[7],
                from_model=row[8],
            )

    async def list_models_by_domain(self, *, domain: str) -> AsyncIterator[models.Model]:
        result = await self._conn.stream(sqlalchemy.text(LIST_MODELS_BY_DOMAIN), {"p1": domain})
        async for row in result:
            yield models.Model(
                id=row[0],
                domain=row[1],
                name=row[2],
                base=row[3],
                ckpt=row[4],
                parent=row[5],
                status=row[6],
                created_at=row[7],
            )

    async def save_human_pref(self, *, task_id: int, order: int, pref: Optional[int]) -> None:
        await self._conn.execute(sqlalchemy.text(SAVE_HUMAN_PREF), {"p1": task_id, "p2": order, "p3": pref})

    async def save_inference(self, arg: SaveInferenceParams) -> None:
        await self._conn.execute(sqlalchemy.text(SAVE_INFERENCE), {
            "p1": arg.id,
            "p2": arg.prompt,
            "p3": arg.image,
            "p4": arg.image_url,
            "p5": arg.mask,
            "p6": arg.mask_url,
            "p7": arg.output,
            "p8": arg.output_url,
            "p9": arg.from_model,
        })

    async def save_sample_asset(self, arg: SaveSampleAssetParams) -> None:
        await self._conn.execute(sqlalchemy.text(SAVE_SAMPLE_ASSET), {
            "p1": arg.task_id,
            "p2": arg.order,
            "p3": arg.group,
            "p4": arg.image,
            "p5": arg.image_url,
            "p6": arg.prompt,
        })

    async def update_model_status(self, *, id: str, status: models.ModelStatus) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_MODEL_STATUS), {"p1": id, "p2": status})

    async def update_sample_tasks(self, arg: UpdateSampleTasksParams) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_SAMPLE_TASKS), {
            "p1": arg.id,
            "p2": arg.latents,
            "p3": arg.timesteps,
            "p4": arg.next_latents,
            "p5": arg.image_torchs,
            "p6": arg.prompt_embeds,
        })

    async def update_sample_to_fine_tune_task(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_SAMPLE_TO_FINE_TUNE_TASK), {"p1": id})

    async def update_task_status(self, *, id: int, handled_at: Optional[datetime.datetime], finished_at: Optional[datetime.datetime]) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_TASK_STATUS), {"p1": id, "p2": handled_at, "p3": finished_at})
