# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.26.0
# source: query.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.database import models


GET_EARLIEST_PENDING_TASK = """-- name: get_earliest_pending_task \\:one
SELECT id, source_model_id, output_model_id, task_type, created_at, handled_at, finished_at, human_prefs, prompt_embeds, latents, timesteps, next_latents, image_torchs FROM tasks
WHERE handled_at IS NULL
ORDER BY created_at DESC
LIMIT 1
"""


GET_FIRST_ASSET_BY_MODEL_ID = """-- name: get_first_asset_by_model_id \\:one
SELECT task_id, "order", prompt, image, image_url, mask, mask_url FROM assets
WHERE task_id = :p1
AND "order" = 0
LIMIT 1
"""


GET_MODEL = """-- name: get_model \\:one
SELECT id, domain, name, base, ckpt, parent, status, created_at FROM models
WHERE id = :p1 LIMIT 1
"""


GET_TASK = """-- name: get_task \\:one
SELECT id, source_model_id, output_model_id, task_type, created_at, handled_at, finished_at, human_prefs, prompt_embeds, latents, timesteps, next_latents, image_torchs FROM tasks
WHERE id = :p1 AND task_type = :p2
LIMIT 1
"""


INSERT_ASSET = """-- name: insert_asset \\:exec
INSERT INTO assets (task_id, "order", prompt, image, image_url, mask, mask_url)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7)
"""


@dataclasses.dataclass()
class InsertAssetParams:
    task_id: str
    order: int
    prompt: str
    image: memoryview
    image_url: str
    mask: memoryview
    mask_url: str


INSERT_BASE_ASSET = """-- name: insert_base_asset \\:exec
INSERT INTO base_assets (id, image, image_url, mask, mask_url, domain)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6)
"""


@dataclasses.dataclass()
class InsertBaseAssetParams:
    id: str
    image: memoryview
    image_url: str
    mask: memoryview
    mask_url: str
    domain: str


INSERT_INFERENCE_TASK = """-- name: insert_inference_task \\:exec
INSERT INTO tasks (id, source_model_id, task_type)
VALUES ( :p1, :p2, 'inference' )
"""


INSERT_MODEL = """-- name: insert_model \\:exec
INSERT INTO models (id, domain, name, base, ckpt)
VALUES (:p1, :p2, :p3, :p4, :p5)
"""


@dataclasses.dataclass()
class InsertModelParams:
    id: str
    domain: str
    name: str
    base: str
    ckpt: Optional[memoryview]


INSERT_PENDING_MODEL = """-- name: insert_pending_model \\:exec
INSERT INTO models (id, domain, name, parent, status)
VALUES (:p1, :p2, :p3, :p4, 'sampling')
"""


INSERT_SAMPLE_TASK = """-- name: insert_sample_task \\:exec
INSERT INTO tasks(id, source_model_id, output_model_id, task_type)
VALUES ( :p1, :p2, :p3, 'sample')
"""


LIST_ALL_TASK_WITH_ASSET = """-- name: list_all_task_with_asset \\:many
SELECT tasks.id, tasks.source_model_id, tasks.output_model_id, tasks.task_type, tasks.created_at, tasks.handled_at, tasks.finished_at, tasks.human_prefs, tasks.prompt_embeds, tasks.latents, tasks.timesteps, tasks.next_latents, tasks.image_torchs, assets.task_id, assets."order", assets.prompt, assets.image, assets.image_url, assets.mask, assets.mask_url
FROM tasks
JOIN assets ON assets.task_id = tasks.id
WHERE assets."order" = 0
ORDER BY tasks.created_at DESC
"""


@dataclasses.dataclass()
class ListAllTaskWithAssetRow:
    tasks: Optional[Any]
    assets: Optional[Any]


LIST_INFERENCES = """-- name: list_inferences \\:many
SELECT id, prompt, image, image_url, mask, mask_url, output, output_url, from_model FROM inferences
LIMIT :p1
OFFSET :p2
"""


LIST_MODELS_BY_DOMAIN = """-- name: list_models_by_domain \\:many
SELECT id, domain, name, base, ckpt, parent, status, created_at FROM models
WHERE domain = :p1
"""


SAVE_INFERENCE = """-- name: save_inference \\:exec
INSERT INTO inferences (id, prompt, image, image_url, mask, mask_url, output, output_url, from_model)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9)
"""


@dataclasses.dataclass()
class SaveInferenceParams:
    id: str
    prompt: Optional[str]
    image: memoryview
    image_url: str
    mask: memoryview
    mask_url: str
    output: memoryview
    output_url: str
    from_model: str


UPDATE_TASK_STATUS = """-- name: update_task_status \\:exec
INSERT INTO tasks (id, source_model_id, task_type, handled_at, finished_at)
VALUES (:p1, '', :p2, :p3, :p4)
ON CONFLICT (id, task_type)
DO UPDATE SET
    handled_at = COALESCE(tasks.handled_at, EXCLUDED.handled_at),
    finished_at = COALESCE(tasks.finished_at, EXCLUDED.finished_at)
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_earliest_pending_task(self) -> Optional[models.Task]:
        row = self._conn.execute(sqlalchemy.text(GET_EARLIEST_PENDING_TASK)).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            human_prefs=row[7],
            prompt_embeds=row[8],
            latents=row[9],
            timesteps=row[10],
            next_latents=row[11],
            image_torchs=row[12],
        )

    def get_first_asset_by_model_id(self, *, task_id: str) -> Optional[models.Asset]:
        row = self._conn.execute(sqlalchemy.text(GET_FIRST_ASSET_BY_MODEL_ID), {"p1": task_id}).first()
        if row is None:
            return None
        return models.Asset(
            task_id=row[0],
            order=row[1],
            prompt=row[2],
            image=row[3],
            image_url=row[4],
            mask=row[5],
            mask_url=row[6],
        )

    def get_model(self, *, id: str) -> Optional[models.Model]:
        row = self._conn.execute(sqlalchemy.text(GET_MODEL), {"p1": id}).first()
        if row is None:
            return None
        return models.Model(
            id=row[0],
            domain=row[1],
            name=row[2],
            base=row[3],
            ckpt=row[4],
            parent=row[5],
            status=row[6],
            created_at=row[7],
        )

    def get_task(self, *, id: str, task_type: models.TaskVariant) -> Optional[models.Task]:
        row = self._conn.execute(sqlalchemy.text(GET_TASK), {"p1": id, "p2": task_type}).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            human_prefs=row[7],
            prompt_embeds=row[8],
            latents=row[9],
            timesteps=row[10],
            next_latents=row[11],
            image_torchs=row[12],
        )

    def insert_asset(self, arg: InsertAssetParams) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_ASSET), {
            "p1": arg.task_id,
            "p2": arg.order,
            "p3": arg.prompt,
            "p4": arg.image,
            "p5": arg.image_url,
            "p6": arg.mask,
            "p7": arg.mask_url,
        })

    def insert_base_asset(self, arg: InsertBaseAssetParams) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_BASE_ASSET), {
            "p1": arg.id,
            "p2": arg.image,
            "p3": arg.image_url,
            "p4": arg.mask,
            "p5": arg.mask_url,
            "p6": arg.domain,
        })

    def insert_inference_task(self, *, id: str, source_model_id: str) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_INFERENCE_TASK), {"p1": id, "p2": source_model_id})

    def insert_model(self, arg: InsertModelParams) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_MODEL), {
            "p1": arg.id,
            "p2": arg.domain,
            "p3": arg.name,
            "p4": arg.base,
            "p5": arg.ckpt,
        })

    def insert_pending_model(self, *, id: str, domain: str, name: str, parent: str) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_PENDING_MODEL), {
            "p1": id,
            "p2": domain,
            "p3": name,
            "p4": parent,
        })

    def insert_sample_task(self, *, id: str, source_model_id: str, output_model_id: Optional[str]) -> None:
        self._conn.execute(sqlalchemy.text(INSERT_SAMPLE_TASK), {"p1": id, "p2": source_model_id, "p3": output_model_id})

    def list_all_task_with_asset(self) -> Iterator[ListAllTaskWithAssetRow]:
        result = self._conn.execute(sqlalchemy.text(LIST_ALL_TASK_WITH_ASSET))
        for row in result:
            yield ListAllTaskWithAssetRow(
                tasks=row[0],
                assets=row[1],
            )

    def list_inferences(self, *, limit: int, offset: int) -> Iterator[models.Inference]:
        result = self._conn.execute(sqlalchemy.text(LIST_INFERENCES), {"p1": limit, "p2": offset})
        for row in result:
            yield models.Inference(
                id=row[0],
                prompt=row[1],
                image=row[2],
                image_url=row[3],
                mask=row[4],
                mask_url=row[5],
                output=row[6],
                output_url=row[7],
                from_model=row[8],
            )

    def list_models_by_domain(self, *, domain: str) -> Iterator[models.Model]:
        result = self._conn.execute(sqlalchemy.text(LIST_MODELS_BY_DOMAIN), {"p1": domain})
        for row in result:
            yield models.Model(
                id=row[0],
                domain=row[1],
                name=row[2],
                base=row[3],
                ckpt=row[4],
                parent=row[5],
                status=row[6],
                created_at=row[7],
            )

    def save_inference(self, arg: SaveInferenceParams) -> None:
        self._conn.execute(sqlalchemy.text(SAVE_INFERENCE), {
            "p1": arg.id,
            "p2": arg.prompt,
            "p3": arg.image,
            "p4": arg.image_url,
            "p5": arg.mask,
            "p6": arg.mask_url,
            "p7": arg.output,
            "p8": arg.output_url,
            "p9": arg.from_model,
        })

    def update_task_status(self, *, id: str, task_type: models.TaskVariant, handled_at: Optional[datetime.datetime], finished_at: Optional[datetime.datetime]) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_TASK_STATUS), {
            "p1": id,
            "p2": task_type,
            "p3": handled_at,
            "p4": finished_at,
        })


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_earliest_pending_task(self) -> Optional[models.Task]:
        row = (await self._conn.execute(sqlalchemy.text(GET_EARLIEST_PENDING_TASK))).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            human_prefs=row[7],
            prompt_embeds=row[8],
            latents=row[9],
            timesteps=row[10],
            next_latents=row[11],
            image_torchs=row[12],
        )

    async def get_first_asset_by_model_id(self, *, task_id: str) -> Optional[models.Asset]:
        row = (await self._conn.execute(sqlalchemy.text(GET_FIRST_ASSET_BY_MODEL_ID), {"p1": task_id})).first()
        if row is None:
            return None
        return models.Asset(
            task_id=row[0],
            order=row[1],
            prompt=row[2],
            image=row[3],
            image_url=row[4],
            mask=row[5],
            mask_url=row[6],
        )

    async def get_model(self, *, id: str) -> Optional[models.Model]:
        row = (await self._conn.execute(sqlalchemy.text(GET_MODEL), {"p1": id})).first()
        if row is None:
            return None
        return models.Model(
            id=row[0],
            domain=row[1],
            name=row[2],
            base=row[3],
            ckpt=row[4],
            parent=row[5],
            status=row[6],
            created_at=row[7],
        )

    async def get_task(self, *, id: str, task_type: models.TaskVariant) -> Optional[models.Task]:
        row = (await self._conn.execute(sqlalchemy.text(GET_TASK), {"p1": id, "p2": task_type})).first()
        if row is None:
            return None
        return models.Task(
            id=row[0],
            source_model_id=row[1],
            output_model_id=row[2],
            task_type=row[3],
            created_at=row[4],
            handled_at=row[5],
            finished_at=row[6],
            human_prefs=row[7],
            prompt_embeds=row[8],
            latents=row[9],
            timesteps=row[10],
            next_latents=row[11],
            image_torchs=row[12],
        )

    async def insert_asset(self, arg: InsertAssetParams) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_ASSET), {
            "p1": arg.task_id,
            "p2": arg.order,
            "p3": arg.prompt,
            "p4": arg.image,
            "p5": arg.image_url,
            "p6": arg.mask,
            "p7": arg.mask_url,
        })

    async def insert_base_asset(self, arg: InsertBaseAssetParams) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_BASE_ASSET), {
            "p1": arg.id,
            "p2": arg.image,
            "p3": arg.image_url,
            "p4": arg.mask,
            "p5": arg.mask_url,
            "p6": arg.domain,
        })

    async def insert_inference_task(self, *, id: str, source_model_id: str) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_INFERENCE_TASK), {"p1": id, "p2": source_model_id})

    async def insert_model(self, arg: InsertModelParams) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_MODEL), {
            "p1": arg.id,
            "p2": arg.domain,
            "p3": arg.name,
            "p4": arg.base,
            "p5": arg.ckpt,
        })

    async def insert_pending_model(self, *, id: str, domain: str, name: str, parent: str) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_PENDING_MODEL), {
            "p1": id,
            "p2": domain,
            "p3": name,
            "p4": parent,
        })

    async def insert_sample_task(self, *, id: str, source_model_id: str, output_model_id: Optional[str]) -> None:
        await self._conn.execute(sqlalchemy.text(INSERT_SAMPLE_TASK), {"p1": id, "p2": source_model_id, "p3": output_model_id})

    async def list_all_task_with_asset(self) -> AsyncIterator[ListAllTaskWithAssetRow]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ALL_TASK_WITH_ASSET))
        async for row in result:
            yield ListAllTaskWithAssetRow(
                tasks=row[0],
                assets=row[1],
            )

    async def list_inferences(self, *, limit: int, offset: int) -> AsyncIterator[models.Inference]:
        result = await self._conn.stream(sqlalchemy.text(LIST_INFERENCES), {"p1": limit, "p2": offset})
        async for row in result:
            yield models.Inference(
                id=row[0],
                prompt=row[1],
                image=row[2],
                image_url=row[3],
                mask=row[4],
                mask_url=row[5],
                output=row[6],
                output_url=row[7],
                from_model=row[8],
            )

    async def list_models_by_domain(self, *, domain: str) -> AsyncIterator[models.Model]:
        result = await self._conn.stream(sqlalchemy.text(LIST_MODELS_BY_DOMAIN), {"p1": domain})
        async for row in result:
            yield models.Model(
                id=row[0],
                domain=row[1],
                name=row[2],
                base=row[3],
                ckpt=row[4],
                parent=row[5],
                status=row[6],
                created_at=row[7],
            )

    async def save_inference(self, arg: SaveInferenceParams) -> None:
        await self._conn.execute(sqlalchemy.text(SAVE_INFERENCE), {
            "p1": arg.id,
            "p2": arg.prompt,
            "p3": arg.image,
            "p4": arg.image_url,
            "p5": arg.mask,
            "p6": arg.mask_url,
            "p7": arg.output,
            "p8": arg.output_url,
            "p9": arg.from_model,
        })

    async def update_task_status(self, *, id: str, task_type: models.TaskVariant, handled_at: Optional[datetime.datetime], finished_at: Optional[datetime.datetime]) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_TASK_STATUS), {
            "p1": id,
            "p2": task_type,
            "p3": handled_at,
            "p4": finished_at,
        })
